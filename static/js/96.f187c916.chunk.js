"use strict";(self.webpackChunkgam=self.webpackChunkgam||[]).push([[96],{8096:(e,a,i)=>{i.r(a),i.d(a,{default:()=>d});var n=i(5043),s=i(3946),t=i(869),c=i(1384),l=i(5328),o=i(9456),r=(i(971),i(579));const d=()=>{const[e,a]=(0,n.useState)({}),[i,d]=(0,n.useState)(!1),[m,h]=(0,n.useState)(0),u=(0,o.wA)();(0,n.useEffect)((()=>{const e=localStorage.getItem("scalability");e&&a(JSON.parse(e));const i=localStorage.getItem("scalabilityPercentage");i&&h(parseFloat(i))}),[]);const p=e=>{const i=e.target.name,n=e.target.checked;a((e=>{const a={...e,[i]:n};return localStorage.setItem("scalability",JSON.stringify(a)),a}))};return(0,n.useEffect)((()=>{const a=Object.values(e).filter((e=>e)).length/12*100;h(a.toFixed(1)),u({type:"SET_SCALABILITY_PERCENTAGE",payload:a.toFixed(1)}),localStorage.setItem("scalabilityPercentage",a.toFixed(1)),d(100===a)}),[e,u]),(0,r.jsx)(s.sK,{children:(0,r.jsxs)(s.UF,{xs:12,children:[(0,r.jsx)(s.E$,{className:"mb-4",children:(0,r.jsxs)(s.W6,{children:[(0,r.jsx)("h4",{children:"Scalability"}),(0,r.jsx)("hr",{}),(0,r.jsx)("div",{children:(0,r.jsxs)(t.A,{variant:"success",children:["Percentage of selected options: ",localStorage.getItem("scalabilityPercentage")||"0.0","%"]})}),(0,r.jsx)("p",{children:"This step aims to empower the application to grow efficiently and adapt to variable environmental demands. The main areas of focus are adding new micro-frontends, load management, and cache strategies."})]})}),(0,r.jsx)(s.E$,{className:"mb-4",children:(0,r.jsx)(s.W6,{children:(0,r.jsx)("section",{children:(0,r.jsxs)(c.A,{defaultActiveKey:"compatibility",id:"technical-feasibilities-tabs",className:"mb-3",children:[(0,r.jsxs)(l.A,{eventKey:"compatibility",title:"Adding Micro-Frontends",children:[(0,r.jsxs)("ul",{className:"no-bullets",children:[(0,r.jsxs)("li",{children:[(0,r.jsx)("em",{children:"Objective:"})," Facilitate the incorporation of new micro-frontends into the existing system."]}),(0,r.jsx)("li",{children:(0,r.jsx)("em",{children:"Recommendations:"})}),(0,r.jsxs)("ul",{className:"no-bullets",children:[(0,r.jsx)("div",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Dynamic Modularization",checked:e["Dynamic Modularization"]||!1,onChange:p}),"Dynamic Modularization: Develop a modular architecture that supports the dynamic addition of new micro-frontends without impacting the existing ones."]})}),(0,r.jsx)("div",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Load Balancing",checked:e["Load Balancing"]||!1,onChange:p}),"Load Balancing: Implement an automatic load balancing system such as orchestration services using tools like Kubernetes to facilitate automatic scaling based on traffic metrics."]})}),(0,r.jsx)("div",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Cache Management",checked:e["Cache Management"]||!1,onChange:p}),"Cache Management: Adopt cache strategies like Redis to temporarily store micro-service responses, improving the throughput of micro-frontend composition. Explore in-memory caching of micro-frontend DOM to reduce the need for recomposition on every request."]})})]})]}),(0,r.jsx)("div",{children:(0,r.jsxs)("div",{className:"blue-box",children:[(0,r.jsx)("strong",{children:"Practical Example: "}),' In a micro-frontend-based e-commerce scenario, a new micro-frontend called "Personalized Recommendations" was added. An automatic load balancing system with Kubernetes was implemented for dynamic scalability based on traffic. To enhance performance, cache strategies including Redis were used to temporarily store micro-service responses and micro-frontend DOM in in-memory caches, reducing the need for recomposition on every request.']})})]}),(0,r.jsxs)(l.A,{eventKey:"integration",title:"Load Management",children:[(0,r.jsxs)("ul",{className:"no-bullets",children:[(0,r.jsxs)("li",{children:[(0,r.jsx)("em",{children:"Objective:"})," Ensure operational efficiency and optimized performance of the application even under increasing demands."]}),(0,r.jsx)("li",{children:(0,r.jsx)("em",{children:"Recommendations:"})}),(0,r.jsxs)("ul",{className:"no-bullets",children:[(0,r.jsx)("li",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Cloud Auto-scalability",checked:e["Cloud Auto-scalability"]||!1,onChange:p}),"Cloud Auto-scalability: Utilize auto-scalability features offered by cloud providers to dynamically adjust the infrastructure based on traffic patterns. Choose efficient computing layers like containers for fast execution and consider managed options like serverless services to simplify infrastructure operationalization."]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Load Prediction and Manual Adjustment",checked:e["Load Prediction and Manual Adjustment"]||!1,onChange:p}),"Load Prediction and Manual Adjustment: Establish a baseline infrastructure capable of handling predictable loads, such as Black Friday sales, by adopting comparison practices between different services and plug-and-play options."]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Latency Optimization with CDN",checked:e["Latency Optimization with CDN"]||!1,onChange:p}),"Latency Optimization with CDN: Utilize a CDN to increase the speed of web page delivery, reducing latency between the client and requested content."]})})]})]}),(0,r.jsxs)("div",{className:"blue-box",children:[(0,r.jsx)("strong",{children:"Practical Example: "}),' To optimize the performance of the e-commerce platform, cloud auto-scalability was leveraged using serverless services and containers to dynamically adjust the infrastructure based on traffic patterns, ensuring fast execution and operational efficiency. To handle predictable peaks like "Black Friday" sales, a baseline infrastructure was established with manual adjustments when necessary, using comparison practices between different services and plug-and-play options. Additionally, a CDN was incorporated to optimize latency, speeding up web page delivery and enhancing the user experience in high-demand scenarios.']})]}),(0,r.jsxs)(l.A,{eventKey:"functional-complexities",title:"Cache Strategies",children:[(0,r.jsxs)("ul",{className:"no-bullets",children:[(0,r.jsxs)("li",{children:[(0,r.jsx)("em",{children:"Objective:"})," Optimize application performance by reducing server load and accelerating response time."]}),(0,r.jsx)("li",{children:(0,r.jsx)("em",{children:"Recommendations:"})}),(0,r.jsxs)("ul",{className:"no-bullets",children:[(0,r.jsx)("li",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Requirements Analysis",checked:e["Requirements Analysis"]||!1,onChange:p}),'Requirements Analysis: Perform an in-depth analysis of the application"s functional requirements, identifying possible complexities.']})}),(0,r.jsx)("li",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Static Content Cache",checked:e["Static Content Cache"]||!1,onChange:p}),"Static Content Cache: Implement caching for static content such as images, stylesheets, and scripts, reducing loading latency."]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Dynamic Data Cache",checked:e["Dynamic Data Cache"]||!1,onChange:p}),"Dynamic Data Cache: Utilize cache strategies for dynamic data, minimizing frequent server queries."]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Efficient Cache Invalidation",checked:e["Efficient Cache Invalidation"]||!1,onChange:p}),"Efficient Cache Invalidation: Implement effective cache invalidation methods to ensure users receive up-to-date information."]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Response Cache",checked:e["Response Cache"]||!1,onChange:p}),"Response Cache: Implement caches to temporarily store micro-frontend responses, using solutions like Redis, temporarily storing micro-service responses to increase throughput."]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"DOM Storage Cache",checked:e["DOM Storage Cache"]||!1,onChange:p}),"DOM Storage Cache: Store the complete DOM of micro-frontends in in-memory caches to avoid excessive recomposition on every request."]})})]})]}),(0,r.jsx)("div",{children:(0,r.jsxs)("div",{className:"blue-box",children:[(0,r.jsx)("strong",{children:"Practical Example: "})," In a web application, caches were introduced for static content (images and stylesheets), dynamic data, and micro-frontend and micro-service responses, using solutions like Redis. These approaches reduce loading latency, minimize frequent server queries, and increase throughput. Additionally, effective cache invalidation methods were adopted to ensure up-to-date information, and the DOM of micro-frontends was stored in in-memory caches, avoiding excessive recomposition on every request."]})})]})]})})})})]})})}}}]);
//# sourceMappingURL=96.f187c916.chunk.js.map