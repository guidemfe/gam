"use strict";(self.webpackChunkgam=self.webpackChunkgam||[]).push([[570],{4570:(e,t,n)=>{n.r(t),n.d(t,{default:()=>d});var i=n(5043),s=n(3946),a=n(869),o=n(1384),l=n(5328),c=n(9456),r=(n(971),n(579));const d=()=>{const[e,t]=(0,i.useState)({}),[n,d]=(0,i.useState)(!1),[m,h]=(0,i.useState)(0),u=(0,c.wA)();(0,i.useEffect)((()=>{const e=localStorage.getItem("maintainability");e&&t(JSON.parse(e));const n=localStorage.getItem("maintainabilityPercentage");n&&h(parseFloat(n))}),[]);const f=e=>{const n=e.target.name,i=e.target.checked;t((e=>{const t={...e,[n]:i};return localStorage.setItem("maintainability",JSON.stringify(t)),t}))};return(0,i.useEffect)((()=>{const t=Object.values(e).filter((e=>e)).length/9*100;h(t.toFixed(1)),u({type:"SET_MAINTAINABILITY_PERCENTAGE",payload:t.toFixed(1)}),localStorage.setItem("maintainabilityPercentage",t.toFixed(1)),d(100===t)}),[e,u]),(0,r.jsx)(s.sK,{children:(0,r.jsxs)(s.UF,{xs:12,children:[(0,r.jsx)(s.E$,{className:"mb-4",children:(0,r.jsxs)(s.W6,{children:[(0,r.jsx)("h4",{children:"Maintainability"}),(0,r.jsx)("hr",{}),(0,r.jsx)("div",{children:(0,r.jsxs)(a.A,{variant:"success",children:["Percentage of selected options: ",localStorage.getItem("maintainabilityPercentage")||"0.0","%"]})}),(0,r.jsx)("p",{children:"ISO/IEC 25010 defines maintainability as the ability of a system to be modified, updated, and adapted. Its main subcharacteristics include Modularity, Reusability, Analyzability, Modifiability, and Testability. In the context of the micro-frontend Adoption Guide (GAM), maintainability emphasizes code, adapting the concepts to focus on Analyzability, Modifiability, and Testability, highlighting the importance of efficient analysis, effective modification, and robust testing of source code in micro-frontend environments."})]})}),(0,r.jsx)(s.E$,{className:"mb-4",children:(0,r.jsx)(s.W6,{children:(0,r.jsx)("section",{children:(0,r.jsxs)(o.A,{defaultActiveKey:"compatibility",id:"technical-feasibilities-tabs",className:"mb-3",children:[(0,r.jsxs)(l.A,{eventKey:"compatibility",title:"Analyzability",children:[(0,r.jsxs)("ul",{className:"no-bullets",children:[(0,r.jsxs)("li",{children:[(0,r.jsx)("em",{children:"Objective:"})," Understand the structure and functioning of micro-frontends to diagnose problems quickly and accurately."]}),(0,r.jsx)("li",{children:(0,r.jsx)("em",{children:"Recommendations:"})}),(0,r.jsxs)("ul",{className:"no-bullets",children:[(0,r.jsx)("div",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Naming Conventions",checked:e["Naming Conventions"]||!1,onChange:f}),"Naming Conventions: Adopt consistent naming conventions to facilitate identification and understanding of components."]})}),(0,r.jsx)("div",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Documentation",checked:e.Documentation||!1,onChange:f}),"Documentation: Maintain detailed documentation about the architecture, interactions, and responsibilities of each micro-frontend."]})}),(0,r.jsx)("div",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Static Analysis Tools",checked:e["Static Analysis Tools"]||!1,onChange:f}),"Static Analysis Tools: Use tools like ESLint and TSLint for static code analysis, identifying patterns, complexity, and potential issues. More comprehensive tools like Sonar can provide a holistic view of code quality, including source code metrics, code coverage, and detection of potential security issues."]})})]})]}),(0,r.jsx)("div",{children:(0,r.jsxs)("div",{className:"blue-box",children:[(0,r.jsx)("strong",{children:"Practical Example: "})," A developer is assigned to update the interface of the product details page. During the process, the developer follows naming conventions, consults the documentation to understand the structure and interactions, while static analysis tools (ESLint and TSLint) flag potential code improvements. Sonar complements this analysis by providing detailed metrics and identifying areas of concern, resulting in efficient and secure modifications to the micro-frontend."]})})]}),(0,r.jsxs)(l.A,{eventKey:"integration",title:"Modifiability",children:[(0,r.jsxs)("ul",{className:"no-bullets",children:[(0,r.jsxs)("li",{children:[(0,r.jsx)("em",{children:"Objective:"})," Enable efficient modifications to micro-frontends without introducing defects or degrading quality."]}),(0,r.jsx)("li",{children:(0,r.jsx)("em",{children:"Recommendations:"})}),(0,r.jsxs)("ul",{className:"no-bullets",children:[(0,r.jsx)("li",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Modular Design",checked:e["Modular Design"]||!1,onChange:f}),"Modular Design: Structure micro-frontends in a modular way, minimizing coupling between them."]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Continuous Refactoring",checked:e["Continuous Refactoring"]||!1,onChange:f}),"Continuous Refactoring: Encourage refactoring practices to keep the code clean and adaptable."]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Version Control",checked:e["Version Control"]||!1,onChange:f}),"Version Control: Use efficient version control systems like Git to track changes and facilitate rollbacks if necessary. Tools like Veracode can be incorporated to perform static and dynamic security analysis, helping to ensure secure modifications."]})})]})]}),(0,r.jsxs)("div",{className:"blue-box",children:[(0,r.jsx)("strong",{children:"Practical Example: "})," A new feature needs to be added to one of the micro-frontends. With modular design, the developer can isolate the implementation of the new feature without affecting other parts of the system. During the process, continuous refactoring practices ensure that the code remains clean and adaptable. Efficient use of version control allows the developer to track and manage changes in an organized manner. Veracode integration checks for potential security vulnerabilities, ensuring secure modifications before deployment."]})]}),(0,r.jsxs)(l.A,{eventKey:"functional-complexities",title:"Testability",children:[(0,r.jsxs)("ul",{className:"no-bullets",children:[(0,r.jsxs)("li",{children:[(0,r.jsx)("em",{children:"Objective:"})," Ensure the effectiveness of tests, allowing early detection of failures and safe changes."]}),(0,r.jsx)("li",{children:(0,r.jsx)("em",{children:"Recommendations:"})}),(0,r.jsxs)("ul",{className:"no-bullets",children:[(0,r.jsx)("li",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Unit and Integration Testing",checked:e["Unit and Integration Testing"]||!1,onChange:f}),"Unit and Integration Testing: Implement unit tests (using Jest and Enzyme for React, for example) and integration tests to verify isolated functionality and interaction between micro-frontends."]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Test Automation",checked:e["Test Automation"]||!1,onChange:f}),"Test Automation: Use test automation tools like Cypress to streamline the verification process."]})}),(0,r.jsx)("li",{children:(0,r.jsxs)("label",{className:"ml-2",children:[(0,r.jsx)("input",{className:"input-label",type:"checkbox",name:"Production-like Test Environments",checked:e["Production-like Test Environments"]||!1,onChange:f}),"Production-like Test Environments: Maintain test environments that faithfully reproduce production conditions to validate the real behavior of the system."]})})]})]}),(0,r.jsx)("div",{children:(0,r.jsxs)("div",{className:"blue-box",children:[(0,r.jsx)("strong",{children:"Practical Example: "})," A new feature is added to a specific micro-frontend. Unit tests ensure that the isolated functionality works as expected, using tools like Jest to validate React components. Integration tests, incorporating tools like Cypress, verify the interaction between different micro-frontends. Automation of these tests streamlines the verification process, allowing the development team to detect potential failures early on. By maintaining production-like test environments, the team ensures that real system conditions are simulated, comprehensively validating the behavior of the micro-frontend before deployment."]})})]})]})})})})]})})}}}]);
//# sourceMappingURL=570.b20bccf8.chunk.js.map